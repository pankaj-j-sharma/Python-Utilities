Best Practices For Flask Security

1. Jinja2 Templating and User-Input
   An attacker can execute arbitrary JavaScript code, which can be executed on each user end 
   if they follow the status feed page in their browsers. To prevent this, we need to mitigate 
   this attack by configuring the flask Jinja2 to auto escape all inputs. By default this is turned off, 
   so the Jinja2 auto escape depends on you.

jinja_options = ImmutableDict(
 extensions=[
  'jinja2.ext.autoescape', 'jinja2.ext.with_' #Turn auto escaping on
 ])

# Autoescaping depends on you
app.jinja_env.autoescape = True | False 


Do not generate an HTML template without Jinja2.
Data should never be sent from uploaded files.
Attribute values should always be quoted.



2. CSRF Protection
   By default, the flask framework has no CSRF protection but we can use 
   Flask-WTF extension to enable the CSRF protection. 

    from flask_wtf.csrf import CSRFProtect
    csrf = CSRFProtect(app)   

    <form method="post">
        {{ form.csrf_token }}
    </form>

    GET requests should be used to retrieve data from the web.
    Sensitive routes that change information should be performed with 
    POST requests in the proper form submission.
    Requests that change the state should be mandated with a CSRF token 
    generated by the server and sent to the userâ€™s browser


3. Directory Traversal 
   In the flask framework, directory traversal can happen if an attacker uploads a 
   file with the name ../../../etc/passwd    

   You should always rename the files coming from clients and assign 
   random strings to filenames strictly.


4. Cookies Protection
  Applications that run on the browser have most common attack vectors of cookies.
  We should always use HTTPS rather than HTTP. 

    app.config.update(
        SESSION_COOKIE_SECURE=True,
        SESSION_COOKIE_HTTPONLY=True,
        SESSION_COOKIE_SAMESITE='Lax',
    )

    #We can set secure cookies in response
    response.set_cookie('key', 'value', secure=True, httponly=True, samesite='Lax')

  This will send the cookies over SSL encrypted wire rather than plain text


5. HTTP Headers
   There are some HTTP headers which can be used to implement some sort of security. 
    @app.after_request
    def apply_caching(response):
        response.headers["X-Frame-Options"] = "SAMEORIGIN"
        response.headers["HTTP-HEADER"] = "VALUE"
        return response

    Content-Security-Policy (CSP)
    Strict-Transport-Security (HSTS)        
    X-Permitted-Cross-Domain-Policies
    X-Frame-Options
    X-XSS-Protection
    X-Content-Type-Options
    X-Download-Options
    Public-Key-Pins (HPKP)  

    